
/// <CardBased/Version1.0>
/// 1.Canvas之间跳转
/// 2.可选择player,读表初始化player
/// 3.读表初始化gamelevel
/// 4.读表初始化enemy
/// 5.实现物体点击响应
/// 6.实现牌堆逻辑
/// 7.实现卡牌技能逻辑:攻击;防御;带Buff;多段伤害;多个目标;特殊类型技能
/// 8.实现enemy技能逻辑
/// 9.替换美术资源,优化美术表现
/// 10.完成整套游戏流程
/// </summary>
/// 


/// 挖坑和填坑
//1. IRoleBase,ICardBase,IGamelevelBase基类接口的必要性
//      用接口定义基类可以解决组件类型脚本继承某一父类的问题
//      但是,当前游戏中因为子类各自有自己的组件脚本,并且属性值来源于各自的数据表
//      因此,用接口定义基类目前看来有些多此一举,增加了脚本的复杂性,没有特别实际的作用
//2. Canvas的正确打开方式
//      当前游戏中,采用2~3个Canvas基本可以满足UI需求,按照从前向后的顺序:
//      置顶层:OverlayMode;弹窗,Tips等界面的根节点
//      模型层:OverlayMode;主要放置3D模型,以及模型属性UI,比如角色血量,Buff等UI资源
//      底层:CameraMode(或Overlay?);实现卡牌操作逻辑和界面基础逻辑
//      核心是要先做好资源存放的构思,避免不必要的Canvas切换
//3. Manager,Assistant类脚本的使用
//      该类型脚本如果不继承MonoBehaviour,则脚本内不能实例化对象,不能销毁对象,不能调用协程
//      如果采用单例来使用此类脚本,要构思脚本是否要挂载到某一特定对象上,或者避免在脚本内进行实例化等操作
//4. 单例内的成员变量
//      单例内的某些成员变量,定义的初衷是为了减少其他脚本中重新定义新成员,为了减少新空间开辟
//      但是,使用上有些繁琐,尤其变量的通用性不多时,反而增加逻辑复杂程度,比如btnJump
//      另一种解决方案是,在其他脚本内采用一个成员变量存储该组件,效果是相同的
//      两种方法,思考在合适的情况,采取合适的方法
//5. 特殊技能的实现方法: 继承接口+多态
//      接口类IUniqueCard中定义虚方法Redefine(); 特殊技能类技能该接口,并重写Redefine(); 
//      CardInitial类中直接调用: transform.GetCompnent<IUniqueCard>().Redefine();


/// 待解决的问题
//1. Id:作为表内行数据的索引,在表内是唯一的;当场景中实例多个相同元素时,增加字段Counter,作为序号标识
//      当卡牌被销毁时,Counter需要重新排序,不能用Counter--处理,以保证Counter连贯
//2. 如果单张卡牌有最大数量限制,可以用Counter=MaxCounter作为条件;或者增加字段CanGet=true;
//      当Counter=MaxCounter,或CanGet=false;该卡不能继续获得
//      Counter与CanGet需要写表才能在初始化时起到作用
//3. 写表的方法
//   